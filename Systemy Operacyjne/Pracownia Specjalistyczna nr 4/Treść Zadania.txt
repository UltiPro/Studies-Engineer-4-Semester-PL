Sygnały są bardzo prostą formą komunikacji międzyprocesowej. Mają one formę wiadomości, która może być asynchronicznie wysłana do danego procesu (lub wątku w ramach danego procesu).
Proces otrzymujący sygnał przerywa swój normalny tryb wykonania i wywołuje akcję przewidzianą dla danego sygnału. Dla większości sygnałów można zdefiniować funkcję (handler  obsługi sygnału),  która będzie wywołana po jego otrzymaniu. Można je również zignorować lub pozostawić ich domyślny handler bez zmian. Części sygnałów (jak SIGKILL czy SIGSTOP) ma przypisaną stałą akcję i nie można ich obsłużyć ani zignorować. Sygnał może się pojawić np. z powodu:

błędu programistycznego (np. segfault);
zakończenia procesu potomnego;
wywołania funkcji raise  przez proces;
Wywołania funkcji/polecenia kill przez inny proces.
Gorąco zachęcam do zapoznania się z dokumentacją glibc: https://www.gnu.org/software/libc/manual/html_node/Signal-Handling.html
Dodatkowo: http://man7.org/linux/man-pages/man7/signal.7.html

Prosty przykład:
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void handler(int signum){
    printf("signal!\n");
    exit(signum);
}

int main(void){
    signal(SIGINT, handler); //TODO obsluga bledow!
    while(1)
    {
        printf("working...\n");
        sleep(1);
    }
    return 0;
}
Skompiluj i uruchom powyższy przykład. Wyślij do działającego programu sygnał SIGINT (skrót CTRL+C w terminalu). Następnie:
Zakomentuj następnie wywołanie exit z funkcji handlera. Co się zmieniło?
Spróbuj wypisać na ekran informację o otrzymanym w handlerze sygnale (funkcja strsignal).
Dodaj kod obsługi błędów do wywołania funkcji signal. Spróbuj następnie ustawić handler na sygnał SIGKILL.

Przykład: Non-Atomic Data Access:

#include <signal.h>
#include <stdio.h>
#include <unistd.h>
   
volatile struct two_words { double a, b; } memory;
  
void handler(int signum)
{
    printf ("%f, %f\n", memory.a, memory.b);
    alarm (1);
}
   
int main (void)
{
    static struct two_words zeros = { 0, 0 }, ones = { 1, 1 };
    signal (SIGALRM, handler);
    memory = zeros;
    alarm (1);
    while (1)
    {
        memory = zeros;
        memory = ones;
    }
}
Skompiluj i uruchom powyższy przykład. Na pierwszy rzut oka wyjście powinno wyglądać mniej więcej tak:

1.000000, 1.000000
0.000000, 0.000000
1.000000, 1.000000
...
Czasami jednak pojawiają się kombinacje zer i jedynek. Dlaczego tak się dzieje?
Na większości nowoczesnym maszyn operacja podstawienia wartości pod zmienną memory będzie wykonywana w kilku instrukcjach procesora. Sygnał może "wstrzelić się" między te operacje, przez co struktura memory może zawierać różne liczby. Proszę zauważyć, że jest to bardzo prosty przykład i w praktyce programu korzystają z dużo bardziej złożonych typów i struktur danych...



Do realizacji dostępne jest również punktowane ćwiczenie z sygnałów (1 punkt):
Zmodyfikuj pierwszy przykład tak aby program działał w pętli do momentu zmiany flagi (zmienna globalna, pamiętaj o jej deklaracji jako volatile!). Flaga powinna zostać ustawiona na false po odebraniu sygnału SIGQUIT (skrót Crtl+\).

Informacje o uruchomieniu programu i otrzymaniu sygnału spróbuj zapisać do logu systemowego (na maszynach w pracowni mogą być problemy z uprawnieniami).
