Potoki (ang. pipes) są mechanizmem komunikacji międzyprocesowej polegającym na przesyłaniu danych między dwoma procesami. Procesy takie są typowo
połączone przez swoje standardowe strumienie: standardowe wyjście jednego procesu jest przekazywane za pomocą potoku do standardowe wejścia drugiego.
Można w taki sposób łączyć ze sobą wiele procesów, przykładowo w uniksowych powłokach może wyglądać to tak:

ls -l | grep .c | less
gdzie znak "|" oznacza stworzenie potoku między strumieniem stdout procesu po prawej stronie a stdin procesu po lewej.
Strumień stderr najczęściej  jest pomijany w potoku (w bashu można go uwzględnić używając "|&" zamiast "|").

Wyróżnić można dwa rodzaje potoków:

potoki anonimowe, istniejące tylko na czas działania procesów;
potoki nazwane (named pipes), działające podobnie, ale istniejące pod postacią pliku specjalnego.
Więcej:
https://www.gnu.org/software/libc/manual/html_node/Pipes-and-FIFOs.html#Pipes-and-FIFOs
http://www.makelinux.net/alp/038.htm
Potoki anonimowe
Potoki anonimowe mają zastosowanie głownie w komunikacji między procesem rodzica a procesem potomnym (utworzonym przez wywołanie fork()).
Proces-rodzic przed "odforkowaniem" może stworzyć potok poprzez polecenie pipe:

int pipe (int filedes[2])
gdzie tablica filedes staje się "uchwytem" do potoku: deskryptory plików do odczytu i zapisu z potoku są ustawione, odpowiednio, na  filedes[0] i filedes[1].
Proces potomny dziedziczy otwarte deskryptory plików (!), dlatego oba procesy mogą komunikować się teraz za pomocą potoku: jeden proces może zapisywać
dane do jednego końca uchwytu filedes, a drugi proces może te dane odczytywać. 
Do zastanowienia: w jaki sposób połączyć ze sobą więcej niż dwa procesy?

Duplikowanie deskryptorów
Tworząc potok oparty o standardowe strumienie często trzeba połączyć odpowiednio ich deskryptory z deskryptorami potoku.
Możemy również chcieć np. przekierować  standardowe wyjście do pliku tekstowego. Do wykonywania tego typu operacji służą funkcje do duplikowania
deskryptorów dup i dup2:

int dup (int old) - kopiuje podany deskryptor old na nowy (pierwszy wolny) numer, który jest wartością zwróconą;
int dup2 (int old, int new) - kopiuje deskryptor old na deskryptor new (numer new pozostaje bez zmian, ale wskazuje on teraz na zasób wykazywany przez old,
new jest zamykany jeśli był wcześniej otwarty).
Więcej:
https://www.gnu.org/software/libc/manual/html_node/Duplicating-Descriptors.html#Duplicating-Descriptors


Przykład
Poniższy kod prezentuje tworzenie potoku wraz z przekierowaniem standardowego wejścia w potomku i uruchomieniem zewnętrznego procesu.
Proces-rodzic tworzy potok, a następnie zapisuje do niego kilka łańcuchów tekstowych. Zapis wykonany jest poprzez API wysokopoziomowe, gdyż
deskryptor potoku został  wykorzystany do stworzenia strumienia poprzez wywołanie fdopen.
Proces potomny z kolei wywołuje zewnętrzny proces (sort), który powinien wypisać otrzymany z potoku tekst w postaci posortowanej.
Komenda sort może przyjąć dane ze standardowego wejścia. Do wykonania tego niezbędne jest skopiowanie końca do odczytu potoku na
deskryptor STDIN_FILENO procesu potomnego (poprzez dup2 (fds[0], STDIN_FILENO));

Do zastanowienia: Proszę zwrócić uwagę na zamykanie odpowiednich końców potoku. Co się stanie jeśli zapomnimy o ich zamknięciu?

___________________________________________________________________________________________________________________________________________

#include <stdio.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
int main ()
{
    int fds[2];
    pid_t pid;
    /* Create a pipe. File descriptors for the two ends of the pipe are placed in fds. */
    /* TODO add error handling for system calls like pipe, fork, etc. */
    pipe (fds);
    /* Fork a child process. */
    pid = fork ();
    if (pid == (pid_t) 0) {
        /* This is the child process. Close our copy of the write end of the file descriptor. */
        close (fds[1]);
        /* Connect the read end of the pipe to standard input. */
        dup2 (fds[0], STDIN_FILENO);
        /* Replace the child process with the "sort” program. */
        execlp ("sort", "sort", NULL);
    } else {
        /* This is the parent process. */
        FILE* stream;
        /* Close our copy of the read end of the file descriptor. */
        close (fds[0]);
        /* Convert the write file descriptor to a FILE object, and write to it. */
        stream = fdopen (fds[1], "w");
        fprintf (stream, "This is a test.\n");
        fprintf (stream, "Hello, world.\n");
        fprintf (stream, "My dog has fleas.\n");
        fprintf (stream, "This program is great.\n");
        fprintf (stream, "One fish, two fish.\n");
        fflush (stream);
        close (fds[1]);
        /* Wait for the child process to finish. */
        waitpid (pid, NULL, 0);
    }
    return 0;
}
___________________________________________________________________________________________________________________________________________

Zadanie
Zmodyfikuj powyższy przykład tak aby proces potomny przekierowywał swoje standardowe wyjście do pliku tekstowego o nazwie przekazanej przez argument funkcji main.
Uzupełnij kod o prawidłową kontrolę błędów wywołań systemowych (1p)
